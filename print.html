<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>imxrt-rs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="ecosystem_walkthrough/index.html"><strong aria-hidden="true">1.</strong> Ecosystem walkthrough</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecosystem_walkthrough/booting.html"><strong aria-hidden="true">1.1.</strong> Booting</a></li><li class="chapter-item expanded "><a href="ecosystem_walkthrough/ral.html"><strong aria-hidden="true">1.2.</strong> Register access layer</a></li><li class="chapter-item expanded "><a href="ecosystem_walkthrough/hal.html"><strong aria-hidden="true">1.3.</strong> Hardware abstraction layer</a></li><li class="chapter-item expanded "><a href="ecosystem_walkthrough/bsp.html"><strong aria-hidden="true">1.4.</strong> Board support package</a></li><li class="chapter-item expanded "><a href="ecosystem_walkthrough/extras.html"><strong aria-hidden="true">1.5.</strong> Extra packages</a></li></ol></li><li class="chapter-item expanded "><a href="toolchain.html"><strong aria-hidden="true">2.</strong> Toolchain setup</a></li><li class="chapter-item expanded "><a href="flash_debug/index.html"><strong aria-hidden="true">3.</strong> Flashing and debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flash_debug/evk_recovery.html"><strong aria-hidden="true">3.1.</strong> Recovering an EVK</a></li><li class="chapter-item expanded "><a href="flash_debug/pyocd_qsg.html"><strong aria-hidden="true">3.2.</strong> pyOCD quick-start guide</a></li></ol></li><li class="chapter-item expanded "><a href="external_docs.html"><strong aria-hidden="true">4.</strong> External documentation</a></li><li class="chapter-item expanded "><a href="new_mcus.html"><strong aria-hidden="true">5.</strong> Contributing new MCUs</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">imxrt-rs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/imxrt-rs/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="imxrt-rs"><a class="header" href="#imxrt-rs">imxrt-rs</a></h1>
<p>User and developer documentation for the imxrt-rs project.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>If you're not familiar with our work, take a look at the <a href="./ecosystem_walkthrough/">ecosystem
walkthrough</a>. The walkthrough demonstrates how you can
combine imxrt-rs packages to support your embedded Rust development.</p>
<p>If you're using an imxrt-rs package, consult the <a href="./toolchain.html">toolchain
setup</a> to prepare your development environment. Our recommended
<a href="./flash_debug/">flashing and debugging tools</a> can help you deploy your
application on your hardware.</p>
<p>For links to helpful references, check out our <a href="./external_docs.html">external documentation
sources</a>.</p>
<p>If you're already familiar with embedded Rust and want to dive in, the best
place to start is in <a href="https://github.com/imxrt-rs/imxrt-hal">the <code>imxrt-hal</code>
repository</a>. You'll find small hardware
examples that run on various development boards.</p>
<h3 id="about"><a class="header" href="#about">About</a></h3>
<p>We provide community support for using Rust on NXP's i.MX RT processors. We
develop hardware drivers with
<a href="https://crates.io/crates/embedded-hal">embedded-hal</a> compatibility. We also
provide packages for embedded application development and debugging. To support
these goals, we collaborate with the broader embedded Rust community.</p>
<p>By supporting this platform, we want to improve the general quality and
accessibility of embedded Rust.</p>
<h3 id="contact"><a class="header" href="#contact">Contact</a></h3>
<ul>
<li>Join the Matrix chat:
<a href="https://matrix.to/#/#imxrt-rs:matrix.org">#imxrt-rs:matrix.org</a>.</li>
<li>Reach out on <a href="https://github.com/imxrt-rs">GitHub</a> issues and discussions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecosystem-walkthrough"><a class="header" href="#ecosystem-walkthrough">Ecosystem walkthrough</a></h1>
<p>The imxrt-rs project develops various packages to support embedded Rust
development on i.MX RT microcontrollers. This walkthrough demonstrates core
<code>no_std</code> imxrt-rs packages by example. The guide shows</p>
<ul>
<li>what crates are necessary to boot an i.MX RT processor.</li>
<li>how the register access layer simplifies register access and resource
ownership.</li>
<li>how to use drivers in the hardware abstraction layer.</li>
</ul>
<p>The walkthrough steps through a series of examples that turns on a evaluation
kit's LED. Each example introduces one or more imxrt-rs package and briefly
explains the package's role in the ecosystem. For more information on a package,
consult its documentation.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before reading this walkthrough, it helps to know general concepts of embedded
Rust development. Familiarize yourself with <a href="https://docs.rust-embedded.org/book/intro/index.html">The Embedded Rust
Book</a> before reading this
walkthrough. The walkthrough specifically assumes knowledge of the
<a href="https://docs.rust-embedded.org/book/portability/index.html">portability</a>
concepts described in the book.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>All examples target NXP's i.MXRT1010EVK development board. Nevertheless, the
concepts apply for all i.MX RT microcontrollers supported by the imxrt-rs
project.</p>
<p>The following <a href="https://doc.rust-lang.org/cargo/reference/config.html">Cargo
configuration</a> applies to
all examples.</p>
<pre><code class="language-toml"># Link with the imxrt-rt linker script.
[target.thumbv7em-none-eabihf]
rustflags = [
    &quot;-C&quot;, &quot;link-arg=-Timxrt-link.x&quot;,
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booting"><a class="header" href="#booting">Booting</a></h1>
<p>In order to boot Rust firmware on an i.MX RT processor, you need at least three
crates:</p>
<ol>
<li>a crate that defines <a href="ecosystem_walkthrough/booting.html#boot-headers">a compatible boot header</a> for your
system.</li>
<li>the <a href="ecosystem_walkthrough/booting.html#runtime"><code>imxrt-rt</code> runtime</a>.</li>
<li>a panic handler.</li>
</ol>
<p>A <code>Cargo.toml</code> package manifest with these dependencies is shown below.</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
# The boot header package.
imxrt1010evk-fcb = &quot;0.1&quot;
# The runtime.
imxrt-rt = &quot;0.1&quot;
# The panic handler.
panic-halt = &quot;0.2&quot;

[build-dependencies]
# The same runtime as above.
imxrt-rt = &quot;0.1&quot;
</code></pre>
<p>The runtime is configured in an application's <code>build.rs</code> script, so the
dependency is included twice. The following build script configures a default
runtime for the i.MXRT1010EVK development board.</p>
<pre><pre class="playground"><code class="language-rust">//! build.rs

use imxrt_rt::{Family, RuntimeBuilder};

fn main() {
    // The iMXRT1010EVK has 16 MiB of flash.
    RuntimeBuilder::from_flexspi(Family::Imxrt1010, 16 * 1024 * 1024)
        .build()
        .unwrap();
}
</code></pre></pre>
<p>Finally, <code>main.rs</code> defines the program that turns on the i.MXRT1010EVK's LED.</p>
<pre><pre class="playground"><code class="language-rust">//! main.rs

#![no_main]
#![no_std]

// Include the boot header like this. Otherwise,
// it may be removed by the linker.
use imxrt1010evk_fcb as _;

// Same goes for the panic handler.
use panic_halt as _;

// The entry macro adorns your main function.
use imxrt_rt::entry;

const LED_OFFSET: u32 = 1 &lt;&lt; 11;

// Register addresses come from the reference manual.
const IOMUXC_MUX_CTL_PAD_GPIO_11: *mut u32 = 0x401F_8090 as _;
const GPIO1_GDIR: *mut u32 = (0x401B_8000 + 0x04) as _;
const GPIO1_DR_SET: *mut u32 = (0x401B_8000 + 0x84) as _;

#[entry]
fn main() -&gt; ! {
    unsafe {
        // Configure the pad named &quot;GPIO_11&quot; as a GPIO pin
        // (as opposed to a UART TX pin, for example).
        IOMUXC_MUX_CTL_PAD_GPIO_11.write_volatile(5);

        // Set the GPIO as an output with a RMW operation.
        let mut gpio1_gdir = GPIO1_GDIR.read_volatile();
        gpio1_gdir |= LED_OFFSET;
        GPIO1_GDIR.write_volatile(gpio1_gdir);

        // Turn on the LED.
        GPIO1_DR_SET.write_volatile(LED_OFFSET);
    }
    loop {}
}
</code></pre></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>This example is sufficient to boot the processor and run a very basic
application. However, it's not a good demonstration of how to write an embedded
Rust application. In particular,</p>
<ul>
<li>the application needs to know register addresses in order to configure
IOMUXC pads and GPIO outputs.</li>
<li>register access is unsafe, since we're reading and writing to raw pointers.</li>
<li>we need to explicitly use volatile reads and writes, and manually code
read-modify-write actions on register fields.</li>
<li>we are not modeling ownership of peripherals.</li>
</ul>
<p>The next section introduces a register access layer that provides register
addresses, exposes safe and convenient register access, and lets you model
peripheral ownership.</p>
<p>The remaining sections describe the boot headers and runtime used in this
example.</p>
<h2 id="boot-headers"><a class="header" href="#boot-headers">Boot headers</a></h2>
<p>The specifics of a boot header vary by system. For example, if your system
interfaces NOR flash using a FlexSPI peripheral, you'll need a crate that
provides a FlexSPI configuration block (FCB). On the other hand, systems that
use parallel NAND flash may need a different kind of boot header. Consult your
processor's reference manual for more information about boot headers.</p>
<p>As an user of these crates, you simply need to include the proper boot header
for your system. imxrt-rs maintains FCBs for various development boards,
including</p>
<ul>
<li>the i.MXRT1010EVK</li>
<li>the i.MXRT1170EVK</li>
</ul>
<p>These FCBs are developed alongside the <a href="https://github.com/imxrt-rs/imxrt-boot-gen"><code>imxrt-boot-gen</code>
package</a>. If no boot header exists
for your system, use <code>imxrt-boot-gen</code> to define your system's boot header.</p>
<p>Other boot headers, like the
<a href="https://github.com/mciantyre/teensy4-rs"><code>teensy4-fcb</code></a>, may be maintained in
separate projects. Boot headers may also be integrated directly within a board
support package.</p>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p>The <a href="https://github.com/imxrt-rs/imxrt-rt"><code>imxrt-rt</code> runtime</a> is an extension
of the <a href="https://crates.io/crates/cortex-m-rt"><code>cortex-m-rt</code> package</a>. The custom
runtime satisfies the boot requirements of i.MX RT processors. It also lets you
customize the program memory layout and utilize tightly-coupled memory (TCM)
regions through the FlexRAM interface.</p>
<p><code>imxrt-rt</code> uses a convention of symbol names and link sections to properly place
boot headers. See the runtime documentation for a discussion on this convention.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="register-access-layer"><a class="header" href="#register-access-layer">Register access layer</a></h1>
<p><a href="https://github.com/imxrt-rs/imxrt-ral">The <code>imxrt-ral</code> crate</a> provides a
register access layer (RAL) for i.MX RT 10xx and 11xx microcontrollers. Use the
RAL to</p>
<ul>
<li>manage peripherals as low-level resources.</li>
<li>conveniently access registers and register fields.</li>
</ul>
<p><code>imxrt-ral</code> also provides a device-specific interrupt table. Once you link the
runtime with the RAL,</p>
<ul>
<li>enable <code>imxrt-rt</code>'s <code>&quot;device&quot;</code> feature.</li>
<li>enable <code>imxrt-ral</code>'s <code>&quot;rt&quot;</code> feature.</li>
</ul>
<blockquote>
<p>ℹ️ The RAL is very similar to the peripheral access crate (PAC) found in other
embedded Rust ecosystems. The major difference is the API used to access
registers.</p>
</blockquote>
<p>This example improves on <a href="ecosystem_walkthrough/./booting.html">the previous walkthrough</a> by using
<code>imxrt-ral</code> to access registers. Note the <code>imxrt-ral</code> feature flag for the
target MCU. Also note that the <code>&quot;device&quot;</code> feature for the runtime is enabled,
and the <code>&quot;rt&quot;</code> feature for <code>imxrt-ral</code> is enabled; even though the example
doesn't use interrupts, you should prefer the device-specific vector table when
available.</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
imxrt-ral = { version = &quot;0.5&quot;, features = [&quot;imxrt1011&quot;, &quot;rt&quot;] }
imxrt-rt = { version = &quot;0.1&quot;, features = [&quot;device&quot;] }

# As before...
imxrt1010evk-fcb = &quot;0.1&quot;
panic-halt = &quot;0.2&quot;

[build-dependencies]
imxrt-rt = { version = &quot;0.1&quot;, features = [&quot;device&quot;] }
</code></pre>
<pre><pre class="playground"><code class="language-rust">//! build.rs (unchanged)

use imxrt_rt::{Family, RuntimeBuilder};

fn main() {
    RuntimeBuilder::from_flexspi(Family::Imxrt1010, 16 * 1024 * 1024)
        .build()
        .unwrap();
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">//! main.rs

#![no_main]
#![no_std]

use imxrt_ral as ral;

use imxrt1010evk_fcb as _;
use imxrt_rt::entry;
use panic_halt as _;

const LED_OFFSET: u32 = 1 &lt;&lt; 11;

#[entry]
fn main() -&gt; ! {
    // Safety: we're the only code that &quot;owns&quot; the IOMUXC and GPIO1 peripherals.
    let iomuxc = unsafe { ral::iomuxc::IOMUXC::instance() };
    let gpio1 = unsafe { ral::gpio::GPIO1::instance() };

    // Configure the pad named &quot;GPIO_11&quot; as a GPIO pin
    // (as opposed to a UART TX pin, for example).
    ral::write_reg!(ral::iomuxc, iomuxc, SW_MUX_CTL_PAD_GPIO_11, 5);
    // Set the GPIO as an output with a RMW operation.
    ral::modify_reg!(ral::gpio, gpio1, GDIR, |gdir| gdir | LED_OFFSET);
    // Turn on the LED.
    ral::write_reg!(ral::gpio, gpio1, DR_SET, LED_OFFSET);

    loop {}
}
</code></pre></pre>
<p>Acquiring peripheral instances is still <code>unsafe</code>. However, macros make it easier
to read, write, and modify registers; and there's no need to maintain register
addresses.</p>
<p>Consider using <code>imxrt-ral</code> when you want to implement higher-level peripheral
drivers. These kinds of convenient, re-usable, and portable peripheral drivers
are the topic of the next section: the hardware abstraction layer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-abstraction-layer"><a class="header" href="#hardware-abstraction-layer">Hardware abstraction layer</a></h1>
<p><a href="https://github.com/imxrt-rs/imxrt-hal">The <code>imxrt-hal</code> crate</a> provides the
hardware abstraction layer (HAL) for i.MX RT microcontrollers. The HAL includes
re-usable hardware drivers for 10xx and 11xx MCUs. Most of the HAL's drivers
implement their corresponding traits from
<a href="https://docs.rs/embedded-hal/latest/embedded_hal/"><code>embedded-hal</code></a>, allowing
you to pair the hardware driver with third-party sensor, actuator, and device
drivers.</p>
<p><code>imxrt-hal</code> drivers adapt the low-level peripheral instances provided by
<code>imxrt-ral</code>, so you can use the HAL by adding it as another package in your
project. Unlike the <a href="ecosystem_walkthrough/./ral.html">previous example</a>, this new example use
<code>imxrt-hal</code> APIs to access pads and prepare a GPIO output.</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
imxrt-hal = { version = &quot;0.5&quot;, features = [&quot;imxrt1010&quot;] }

# As before...
imxrt-ral = { version = &quot;0.5&quot;, features = [&quot;imxrt1011&quot;, &quot;rt&quot;] }
imxrt-rt = { version = &quot;0.1&quot;, features = [&quot;device&quot;] }
imxrt1010evk-fcb = &quot;0.1&quot;
panic-halt = &quot;0.2&quot;

[build-dependencies]
imxrt-rt = { version = &quot;0.1&quot;, features = [&quot;device&quot;] }
</code></pre>
<pre><pre class="playground"><code class="language-rust">//! build.rs (unchanged)

use imxrt_rt::{Family, RuntimeBuilder};

fn main() {
    RuntimeBuilder::from_flexspi(Family::Imxrt1010, 16 * 1024 * 1024)
        .build()
        .unwrap();
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">//! main.rs

#![no_main]
#![no_std]

use imxrt_hal as hal;
use imxrt_ral as ral;

use imxrt1010evk_fcb as _;
use imxrt_rt::entry;
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    // Safety: we're the only code that &quot;owns&quot; the IOMUXC and GPIO1 peripherals.
    let iomuxc = unsafe { ral::iomuxc::IOMUXC::instance() };
    let gpio1 = unsafe { ral::gpio::GPIO1::instance() };

    let mut gpio1 = hal::gpio::Port::new(gpio1);
    let pads = hal::iomuxc::into_pads(iomuxc);

    // Configures the pad named &quot;GPIO_11&quot; as a GPIO output.
    let led = gpio1.output(pads.gpio.p11);
    // Turn on the LED.
    led.set();

    loop {}
}
</code></pre></pre>
<h2 id="try-the-hal"><a class="header" href="#try-the-hal">Try the HAL</a></h2>
<p>The <code>imxrt-hal</code> repository includes a collection of hardware examples that work
on various boards, including the</p>
<ul>
<li>Teensy 4 (both 4.0 and 4.1).</li>
<li>NXP's i.MXRT1010EVK.</li>
<li>Cortex-M7 of NXP's i.MXRT1170EVK.</li>
</ul>
<p>You can use these examples to try the HAL on your hardware. See <a href="https://github.com/imxrt-rs/imxrt-hal">the repository
documentation</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="board-support-package"><a class="header" href="#board-support-package">Board support package</a></h1>
<p>A board support package (BSP) combines the previously-covered packages -- the
runtime, boot header, RAL, and HAL -- into a crate for a specific hardware
system. You can describe this system in terms of</p>
<ul>
<li>its i.MX RT processor</li>
<li>the pinout and supported peripherals</li>
</ul>
<p>As of this writing, the imxrt-rs project is not actively maintaining BSPs. But
with your help and contributions, we're happy to start BSP development. If
you're interested in using or maintaining a BSP, reach out to an imxrt-rs
maintainer.</p>
<p>Some BSPs, like <a href="https://github.com/mciantyre/teensy4-rs">the <code>teensy4-bsp</code></a>,
depend on imxrt-rs packages but are maintained as separate projects. If you're
interested in designing a BSP, the <code>teensy4-bsp</code> may have ideas for you.</p>
<p>The rest of this document has recommendations for BSP design, and it
demonstrates a small BSP that can manage hardware resources.</p>
<h2 id="renaming-pads"><a class="header" href="#renaming-pads">Renaming pads</a></h2>
<p>Your board may have a pad (pin) naming convention that differs from the i.MX RT
processor pad naming. For example, the Teensy 4.0 and 4.1 identifies pins by
incrementing numbers starting at zero, and these pins are mapped to i.MX RT 1062
processor pads. Similarly, an NXP EVK may identify pins by a header &amp; pin number
combination, rather than a processor pad. Users might prefer using board names,
rather than processor pad names, in their firmware, and the BSP can provide this
renaming.</p>
<p>As a BSP designer, you can choose to rename pads</p>
<ol>
<li>directly within the BSP.</li>
<li>as a separate &quot;pins&quot; package that's co-developed with the BSP.</li>
</ol>
<p>If you're choosing the first approach, you can refer to pad types and objects
through <code>imxrt-hal</code>. See the <code>imxrt-hal</code> documentation and API for more
information.</p>
<p>If you're choosing the second approach, you should directly use <a href="https://github.com/imxrt-rs/imxrt-iomuxc">the
<code>imxrt-iomuxc</code> crate</a>. By designing
directly to <code>imxrt-iomuxc</code>, you do not need to depend on the larger HAL package
for your pins package. And since <code>imxrt-hal</code> re-exports <code>imxrt-iomuxc</code>, your
pins package will still work with <code>imxrt-hal</code>. For more design guidance, see the
<code>imxrt-iomuxc</code> documentation. This second approach lets others re-use your pins
package without needing to adopt an <code>imxrt-hal</code> dependency.</p>
<p>Take a look at <a href="https://github.com/mciantyre/teensy4-rs">the <code>teensy4-pins</code>
package</a> for an example of a pins
package. Notice how the package renames, and restricts, the i.MX RT processor
pads to those supported by the Teensy 4. Also notice how it depends only on
<code>imxrt-iomuxc</code>, and how it fits within the <code>teensy4-bsp</code> package.</p>
<h2 id="manage-peripheral-resources"><a class="header" href="#manage-peripheral-resources">Manage peripheral resources</a></h2>
<p>If you re-read the code presented in this walkthrough, you'll notice that the
<code>unsafe</code> keyword appears in all three examples. This includes the example that
uses <code>imxrt-hal</code>. By design, acquiring an <code>imxrt-ral</code> peripheral instance is
unsafe; see the <code>imxrt-ral</code> API documentation for the rational. This means that
constructing an <code>imxrt-hal</code> driver needs an <code>unsafe</code> call to acquire the
peripheral instance.</p>
<p>A BSP may be the place to implement a resource management policy. This is
especially true if the BSP</p>
<ul>
<li>only supports a single application with a single entrypoint.</li>
<li>dictates the available hardware resources for the user.</li>
</ul>
<p>If your BSP follows these concepts, you can design your BSP to configure and
release hardware resources to the user. With a simple atomic boolean, the BSP
can ensure that resources are only configured and released once, meeting the
safety requirements for <code>imxrt-ral</code> instance access.</p>
<p>For a rough example of this pattern, see the <code>board</code> package maintained in <a href="https://github.com/imxrt-rs/imxrt-hal">the
<code>imxrt-hal</code> repository</a>. The <code>board</code>
package is designed to expedite hardware testing and example development, and it
handles <code>unsafe</code> instance access on behalf of the example user.</p>
<h2 id="a-small-multi-bsp-example"><a class="header" href="#a-small-multi-bsp-example">A small multi-BSP example</a></h2>
<p>This small BSP example demonstrates the peripheral resource management concept,
though with some limitations. It builds on <a href="ecosystem_walkthrough/./hal.html">the previous example</a> that
turns on one board's LED. To make it interesting, the example supports three
different boards:</p>
<ul>
<li>Teensy 4</li>
<li>i.MXRT1010EVK</li>
<li>i.MXRT1170EVK (Cortex-M7)</li>
</ul>
<p>However, to stay concise, the example only demonstrates resource initialization
for the i.MXRT1010EVK.</p>
<p>The example uses Cargo features to select a target board. The <code>Cargo.toml</code>
snippet below demonstrates the dependencies and feature configurations. A
feature combines</p>
<ul>
<li>an <code>imxrt-ral</code> chip selection</li>
<li>an <code>imxrt-hal</code> family selection</li>
<li>a boot header</li>
</ul>
<p>to describe a board. The <code>imxrt-ral</code> and <code>imxrt-hal</code> features ensure that the
peripherals and drivers are configured for the board's processor. Similarly, the
boot header ensures that the runtime can boot the board's processor.</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
imxrt-hal = { version = &quot;0.5&quot; }
imxrt-ral = { version = &quot;0.5&quot;, features = [&quot;rt&quot;] }
imxrt-rt = { version = &quot;0.1&quot;, features = [&quot;device&quot;] }

teensy4-fcb      = { version = &quot;0.4&quot;, optional = true }
imxrt1010evk-fcb = { version = &quot;0.1&quot;, optional = true }
imxrt1170evk-fcb = { version = &quot;0.1&quot;, optional = true }

panic-halt = &quot;0.2&quot;
cfg-if = &quot;1&quot;

[build-dependencies]
imxrt-rt = { version = &quot;0.1&quot;, features = [&quot;device&quot;] }

[features]
# board = [
#     &quot;imxrt-ral/${CHIP},
#     &quot;imxrt-hal/${FAMILY},
#     &quot;${BOOT_HEADER},
# ]
teensy4 = [
    &quot;imxrt-ral/imxrt1062&quot;,
    &quot;imxrt-hal/imxrt1060&quot;,
    &quot;dep:teensy4-fcb&quot;,
]
imxrt1010evk = [
    &quot;imxrt-ral/imxrt1011&quot;,
    &quot;imxrt-hal/imxrt1010&quot;,
    &quot;dep:imxrt1010evk-fcb&quot;,
]
imxrt1170evk-cm7 = [
    &quot;imxrt-ral/imxrt1176_cm7&quot;,
    &quot;imxrt-hal/imxrt1170&quot;,
    &quot;dep:imxrt1170evk-fcb&quot;,
]
</code></pre>
<p>The <code>build.rs</code> runtime configuration is aware of these three boards, and it
configures the runtime based on the board's chip and flash size.</p>
<pre><pre class="playground"><code class="language-rust">//! build.rs

use imxrt_rt::{Family, RuntimeBuilder};

struct Board {
    family: Family,
    flash_size: usize,
}

const BOARD: Board = if cfg!(feature = &quot;teensy4&quot;) {
    Board {
        family: Family::Imxrt1060,
        flash_size: 1984 * 1024,
    }
} else if cfg!(feature = &quot;imxrt1010evk&quot;) {
    Board {
        family: Family::Imxrt1010,
        flash_size: 16 * 1024 * 1024,
    }
} else if cfg!(feature = &quot;imxrt1170evk-cm7&quot;) {
    Board {
        family: Family::Imxrt1170,
        flash_size: 16 * 1024 * 1024,
    }
} else {
    panic!(&quot;No board selected!&quot;)
};

fn main() {
    RuntimeBuilder::from_flexspi(BOARD.family, BOARD.flash_size)
        .build()
        .unwrap();
}
</code></pre></pre>
<p>Here's the application code. The <code>board</code> module conditionally exposes a board's
<code>Resources</code> based on the board selection.</p>
<p>By convention, all boards define a <code>Resources</code> struct, which can be <code>take</code>n. The
object contains a <code>led</code> member of type <code>Led</code>. The <code>Led</code> type is an alias for an
<code>imxrt-hal</code> GPIO output, which wraps a specific processor pin.</p>
<p>Notice that there is no <code>unsafe</code> in this application code. The <code>board</code> module,
and its submodules, make sure that board <code>Resources</code> are only taken once. Our
dependencies are not also constructing <code>imxrt-ral</code> peripheral instances, which
means that all <code>unsafe</code> peripheral instance access happens within <code>board</code>.</p>
<pre><pre class="playground"><code class="language-rust">//! main.rs

#![no_main]
#![no_std]

use imxrt_hal as hal;
use imxrt_ral as ral;

use imxrt_rt::entry;
use panic_halt as _;

mod board {
    use core::sync::atomic::{AtomicBool, Ordering};

    /// Called by a board implementation to mark peripherals taken.
    fn take() -&gt; Option&lt;()&gt; {
        static BOARD_FREE: AtomicBool = AtomicBool::new(true);
        BOARD_FREE.swap(false, Ordering::SeqCst).then_some(())
    }

    cfg_if::cfg_if! {
        if #[cfg(feature = &quot;teensy4&quot;)] {
            mod teensy4;
            pub use teensy4::Resources;
        } else if #[cfg(feature = &quot;imxrt1010evk&quot;)] {
            mod imxrt1010evk;
            pub use imxrt1010evk::Resources;
        } else if #[cfg(feature = &quot;imxrt1170evk-cm7&quot;)] {
            mod imxrt1170evk_cm7;
            pub use imxrt1170evk_cm7::Resources;
        } else {
            compile_error!(&quot;No board selected!&quot;);
        }
    }
}

#[entry]
fn main() -&gt; ! {
    let board::Resources { led, .. } = board::Resources::take().unwrap();
    led.set();

    loop {}
}
</code></pre></pre>
<p>The i.MXRT1010EVK board implementation is shown below. The implementation
demonstrates the convention of items expected by the application. If the call to
<code>super::take()</code> returns <code>None</code>, it means that the <code>imxrt-ral</code> peripheral
instances already exist, and <code>board</code> refuses to alias those instances and their
wrapping <code>Resources</code>. Otherwise, this is the first time that <code>Resources</code> are
being taken, so it's safe to create <code>imxrt-ral</code> peripheral instances and their
drivers.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! board/imxrt1010evk.rs

use crate::{
    hal::{self, iomuxc::pads},
    ral,
};
use imxrt1010evk_fcb as _;

pub type Led = hal::gpio::Output&lt;pads::gpio::GPIO_11&gt;;

#[non_exhaustive]
pub struct Resources {
    pub led: Led,
}

impl Resources {
    pub fn take() -&gt; Option&lt;Self&gt; {
        super::take()?;

        let iomuxc = unsafe { ral::iomuxc::IOMUXC::instance() };
        let gpio1 = unsafe { ral::gpio::GPIO1::instance() };

        let mut port = hal::gpio::Port::new(gpio1);
        let pads = hal::iomuxc::into_pads(iomuxc);
        let led = port.output(pads.gpio.p11);
        Some(Resources { led })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>board</code> implementation also uses the boot header crate, meeting the
requirements discussed in <a href="ecosystem_walkthrough/./booting.html">booting</a>. Although it's not depicted in
this example, the <code>Led</code> type and <code>Resources::take()</code> implementation vary for
each board. And although it's not required for this small BSP, a
<code>non_exhaustive</code> attribute on <code>Resources</code> requires that users match only the
board resources they expect, permitting boards to add new resources without
breaking users.</p>
<p>A BSP following this design can manage lower-level peripheral instances for the
user, and present higher-level drivers to the user. Furthermore, it presents an
interface that may let users port their applications across different boards.
However, the approach has some limitations.</p>
<h3 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h3>
<p>As of this writing, the developer is the <code>imxrt-ral</code> resource management
strategy. Specifically, the developer must ensure that it's safe to acquire
<code>imxrt-ral</code> peripheral instances in their system. In this BSP example, the
developer knows that this application is the only software executing on the
hardware, so it's the sole owner of the <code>imxrt-ral</code> peripheral instances.
However, it may not be safe to deploy this BSP in systems where multiple (Rust)
applications concurrently execute and use the same hardware resources. In lieu
of an integrated resource management strategy, the <code>unsafe</code> instance access is
the developer's cue to handle these possibilities, or to document assumptions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extra-packages"><a class="header" href="#extra-packages">Extra packages</a></h1>
<p>The imxrt-rs project maintains additional packages to support embedded Rust
development on i.MX RT processors. This page lists some of those extra packages.
For the complete list of packages, check out <a href="https://github.com/imxrt-rs">our GitHub
organization</a>.</p>
<h2 id="imxrt-iomuxc"><a class="header" href="#imxrt-iomuxc">imxrt-iomuxc</a></h2>
<p><a href="https://github.com/imxrt-rs/imxrt-iomuxc"><code>imxrt-iomuxc</code></a> provides an alternate
IOMUXC API than what's provided by <code>imxrt-ral</code>. This package</p>
<ul>
<li>provides a pad configuration API.</li>
<li>defines processor pads.</li>
<li>specifies the peripheral functions supported by each pad.</li>
</ul>
<p><code>imxrt-hal</code> re-exports and extends this API; if you're using <code>imxrt-hal</code>, you
already depend on this package. However, there are <a href="ecosystem_walkthrough/./bsp.html#renaming-pads">some
reasons</a> to use <code>imxrt-iomuxc</code> as your direct
dependency.</p>
<h2 id="imxrt-usbd"><a class="header" href="#imxrt-usbd">imxrt-usbd</a></h2>
<p><a href="https://github.com/imxrt-rs/imxrt-usbd"><code>imxrt-usbd</code></a> implements a high-speed
USB bus. The driver is compatible with the
<a href="https://crates.io/crates/usb-device"><code>usb-device</code></a> ecosystem. <code>imxrt-hal</code>
re-exports and extends the API, but you may use the package directly.</p>
<h2 id="imxrt-log"><a class="header" href="#imxrt-log">imxrt-log</a></h2>
<p><a href="https://github.com/imxrt-rs/imxrt-hal"><code>imxrt-log</code></a> builds on <code>imxrt-hal</code> to
provide convenient developer logging. <code>imxrt-log</code> works with the
<a href="https://crates.io/crates/log"><code>log</code></a> and
<a href="https://crates.io/crates/defmt"><code>defmt</code></a> logging frameworks. Transports include
USB serial and LPUART.</p>
<h2 id="imxrt-dma"><a class="header" href="#imxrt-dma">imxrt-dma</a></h2>
<p><a href="https://github.com/imxrt-rs/imxrt-dma"><code>imxrt-dma</code></a> provides a DMA driver for
supported i.MX RT processors. Use it to schedule DMA transfers, and to await DMA
transfers in <code>async</code> code. <code>imxrt-hal</code> configures a DMA driver and re-exports
most of the API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toolchain-setup"><a class="header" href="#toolchain-setup">Toolchain setup</a></h1>
<p>In order to build Rust applications for i.MX RT MCUs, you'll need a Rust
toolchain and target that supports the MCU. This brief setup guide shows how to
install a compatible Rust target for the i.MX RT.</p>
<p><a href="https://rustup.rs"><code>rustup</code></a> is an official Rust project that simplifies
toolchain setup and maintenance. This setup guide assumes that you're using
<code>rustup</code> to manage your existing Rust toolchain.</p>
<p>Releases of most imxrt-rs packages target the latest, stable Rust release. Make
sure that you have the latest, stable Rust release by updating your toolchain:</p>
<pre><code class="language-bash">rustup update stable
</code></pre>
<p>Then, use <code>rustup</code> to install the <code>thumbv7em-none-eabihf</code> target:</p>
<pre><code class="language-bash">rustup target add thumbv7em-none-eabihf
</code></pre>
<p>Since the CPU supports double-precision floating point operations, most imxrt-rs
documentation assumes the hard-float target. Consider installing and using the
hard-float target if you want to precisely follow imxrt-rs documentation. You're
otherwise free to substitute your preferred, equivalent target.</p>
<p>Once the target is installed, supply it to compatible Cargo commands with
<code>--target</code>.</p>
<pre><code class="language-bash">cargo build --target=thumbv7em-none-eabihf
</code></pre>
<p>Alternatively, use <a href="https://doc.rust-lang.org/cargo/reference/config.html">a Cargo
configuration</a> to set
<code>thumbv7em-none-eabihf</code> as the default target. The snippet below shows an
example of the configuration.</p>
<pre><code class="language-toml">[build]
target = &quot;thumbv7em-none-eabihf&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flashing-and-debugging"><a class="header" href="#flashing-and-debugging">Flashing and debugging</a></h1>
<p>Once you've developed an embedded Rust application for your i.MX RT target,
you'll need additional tools to flash and debug your target. This page links to
tools that can flash and debug i.MX RT targets. It also describes tips for
integrating flashing and debugging tools in your Rust project.</p>
<p>In order to flash and debug an i.MX RT target, you'll need a physical debug
probe that</p>
<ul>
<li>is compatible with your chosen flashing and debugging software.</li>
<li>works with your hardware.</li>
</ul>
<p>Consult each software tool's documentation to understand its support for your
debug probe.</p>
<h2 id="recommendations-for-imx-rt-evks"><a class="header" href="#recommendations-for-imx-rt-evks">Recommendations for i.MX RT EVKs</a></h2>
<p>When working with NXP's i.MX RT EVKs, we recommend either <a href="flash_debug/index.html#pyocd">pyOCD</a> or a
<a href="flash_debug/index.html#probe-rs">probe-rs</a>-based tool. Both of these tools can flash and debug the
i.MX RT processor through the OpenSDA probe available on the board. This
approach doesn't require an external JTAG / SWD debug probe.</p>
<p>Connect to the OpenSDA probe using a USB cable, and ensure that the board's
jumpers are configured to use the OpenSDA probe. Consult your board's
documentation for the specific USB port and jumper configurations.</p>
<p>If you've flashed a bad program to your EVK and you're having trouble
reprogramming the board, see <a href="flash_debug/./evk_recovery.html">recovering an EVK</a>.</p>
<h2 id="pyocd"><a class="header" href="#pyocd">pyOCD</a></h2>
<p><a href="https://pyocd.io">pyOCD</a> is a Python toolkit for debugging and programming Arm
microcontrollers. It includes support for debugging i.MX RT 10xx and 11xx
processors. It can also program external NOR flash chips, making it suitable for
persistent device programming.</p>
<p>See <a href="flash_debug/./pyocd_qsg.html">our quick-start guide</a> if you're interested in using pyOCD
as a flashing and debugging tool.</p>
<p>You can also use pyOCD as a Cargo runner. For more information, see the
<a href="flash_debug/index.html#tips">Tips</a> section.</p>
<h2 id="probe-rs"><a class="header" href="#probe-rs">probe-rs</a></h2>
<p><a href="https://probe.rs">probe-rs</a> develops embedded debugging tools in Rust. All
tools that build on probe-rs, including</p>
<ul>
<li><a href="https://github.com/probe-rs/cargo-flash"><code>cargo-flash</code></a></li>
<li><a href="https://github.com/probe-rs/cargo-embed"><code>cargo-embed</code></a></li>
<li><a href="https://github.com/knurling-rs/probe-run"><code>probe-run</code></a></li>
</ul>
<p>should support i.MX RT 10xx and 11xx processors. probe-rs can write your binary
to external NOR flash chips, just like pyOCD. Consult each tool's documentation
for installation and usage.</p>
<blockquote>
<p>ℹ️ i.MX RT support in probe-rs is in its early stages. Patches for i.MX RT
processors may not yet be accepted or released. If that's the case, consider
building tools from source.</p>
</blockquote>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<p>These tips may be helpful for integrating flashing and debugging tools in your
workflow. They may work for flashing and debugging tools that are not covered by
this guide.</p>
<h3 id="use-a-cargo-runner"><a class="header" href="#use-a-cargo-runner">Use a Cargo runner</a></h3>
<p>A runner describes the behavior of <code>cargo run</code> and other <code>cargo</code> commands. You
can use a Cargo runner to invoke your flashing and debugging tool. See <a href="https://doc.rust-lang.org/cargo/reference/config.html">the
Configuration chapter</a> of
The Cargo Book for more information.</p>
<p>Here's an example of a runner that uses <code>pyocd</code> to program a i.MX RT 1010
microcontroller. This assumes that you have <code>pyocd</code> installed. Once this
configuration is specified in your project,
<code>cargo run --target=thumbv7em-none-eabihf</code> will invoke <code>pyocd</code> to flash your
target.</p>
<pre><code class="language-toml">[target.thumbv7em-none-eabihf]
runner = [
    &quot;pyocd&quot;, &quot;load&quot;,
    &quot;--target=mimxrt1010&quot;,
    &quot;--format=elf&quot;,
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recovering-an-evk"><a class="header" href="#recovering-an-evk">Recovering an EVK</a></h1>
<p>Sometimes, your debug probe fails to connect to the i.MX RT processor on your
NXP EVK. Simple troubleshooting approaches, like resetting power, cannot resolve
the issue. As a result, you're unable to flash a known, good program to recover
the board.</p>
<p>If you're experiencing this problem, try these steps to recover your board. This
guide assumes</p>
<ul>
<li>you're using a NXP EVK, or equivalent hardware, that has switches to control
the processor boot order.</li>
<li>your processor typically executes out of on-board flash.</li>
<li>you have a known, good program to load onto your board's flash.</li>
</ul>
<h2 id="recovery-steps"><a class="header" href="#recovery-steps">Recovery steps</a></h2>
<ol>
<li>Power off your board.</li>
<li>Locate the boot mode switches on your board. Consult your board's
documentation for the switch locations.</li>
<li>Use the switches to change the boot mode to &quot;serial downloader.&quot; Consult
your board's documentation to understand possible boot mode configurations.</li>
<li>Power on your board. Observe that the program stored in the board's flash is
not executing.</li>
<li>Use your normal process to flash a known, good program. This step should now
succeed.</li>
<li>Power off your board.</li>
<li>Revert the boot mode switches back to their previous configuration.</li>
<li>Power on your board. Observe that the known, good program executes from
flash.</li>
</ol>
<p>After flashing the known, good program, you should be able to reprogram the
board without changing the boot mode.</p>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>By changing the boot mode to &quot;serial downloader,&quot; we use the serial bootloader,
stored in the processor's boot ROM, as an ephemeral, known, good program. Your
probe should have better luck connecting to the processor when the processor is
simply waiting for commands over LPUART / USB.</p>
<p>If these steps are not sufficient to recover your board, your hardware may be in
a more troublesome state. Refer to your board's documentation for additional
troubleshooting steps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pyocd-quick-start-guide"><a class="header" href="#pyocd-quick-start-guide">pyOCD quick-start guide</a></h1>
<blockquote>
<p>This guide was developed against pyOCD 0.34. For the most up-to-date
information, study the pyOCD documentation.</p>
</blockquote>
<p>Check out the pyOCD documentation for installation methods. Once installed, list
all supported targets, and filter for the i.MX RT targets.</p>
<pre><code>pyocd list --targets | grep -i imxrt
</code></pre>
<p>The left-most column has a list of i.MX RT targets. Select the one that most
closely matches your processor. We'll call this <code>$TARGET</code> in the rest of this
section.</p>
<blockquote>
<p>Note that pyOCD identifies processors by their chip families, not part
numbers. You should select the target by the chip family. For example, use the
<strong>1060</strong> pyOCD target if your chip is numbered <strong>1062</strong>.</p>
</blockquote>
<p>Connect your hardware to your development host. To <strong>reset</strong> the processor, use
the <code>reset</code> command. To make it more obvious that a reset succeeded, consider
using <code>--halt</code> to stop the processor after the reset.</p>
<pre><code>pyocd reset --target=$TARGET --halt
</code></pre>
<p>To <strong>load / flash</strong> a (ELF) program that's built for your target, use the <code>load</code>
command.</p>
<pre><code>pyocd load --target=$TARGET --format=elf [path/to/your/program]
</code></pre>
<p>Cargo generates ELF files by default, so you should prefer the ELF format in
most cases. However, you can change the <code>--format</code> argument if your executable
is in a different format.</p>
<p>To <strong>debug</strong> your program, use pyOCD as a GDB server.</p>
<pre><code>pyocd gdbserver --target=$TARGET
</code></pre>
<p>Then, connect to the GDB server with your tool of choice. See <a href="https://pyocd.io/docs/gdb_setup.html">GDB
setup</a> for more information. Note that
you'll need a minimally-optimized Rust program in order to have an effective
debug session.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-documentation"><a class="header" href="#external-documentation">External documentation</a></h1>
<p>This page links to external documentation that might help you understand i.MX RT
processors. It also links to embedded Rust documentation, which you should study
if you're new to embedded Rust development.</p>
<h2 id="datasheets"><a class="header" href="#datasheets">Datasheets</a></h2>
<p>i.MX RT data sheets are available as free downloads
<a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/i-mx-rt-crossover-mcus:IMX-RT-SERIES">here</a>.
The data sheets are useful for understanding high-level capabilities of i.MX RT
processors. Select your processor, then go to &quot;Documentation,&quot; then &quot;Data
Sheet.&quot;</p>
<h2 id="reference-manuals"><a class="header" href="#reference-manuals">Reference manuals</a></h2>
<p>i.MX RT reference manuals are available from NXP. The reference manuals describe
the i.MX RT registers and peripheral capabilities, and they're the source of
truth for most driver development.</p>
<p>To download a reference manual, go
<a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/i-mx-rt-crossover-mcus:IMX-RT-SERIES">here</a>
and select your processor. Then, go to &quot;Documentation,&quot; and scroll down to
&quot;Reference Manual.&quot; You'll need a free NXP account to access the reference
manuals.</p>
<h2 id="application-notes"><a class="header" href="#application-notes">Application notes</a></h2>
<p>There's many application notes (AN) for i.MX RT processors. They're available
through the same documentation portal that serves datasheets and reference
manuals.</p>
<p>Some ANs of interest are listed below.</p>
<ul>
<li><a href="https://www.nxp.com/docs/en/application-note/AN12077.pdf">AN12077: Using the i.MX RT
FlexRAM</a> talks
about how to configure tightly-coupled memory (TCM). It's useful information
for understanding <code>imxrt-rt</code>.</li>
<li><a href="https://www.nxp.com/docs/en/nxp/application-notes/AN12238.pdf">AN12238: i.MX RT Flashloader Use
Case</a> is
helpful for understanding the i.MX RT boot image. It's also useful for
understanding <code>imxrt-rt</code>.</li>
<li><a href="https://www.nxp.com/docs/en/application-note/AN13264.pdf">AN13264: i.MX RT1170 Dual Core
Application</a>
summarizes the boot process for the second core on an 11xx processor.</li>
<li><a href="https://www.nxp.com/docs/en/application-note/AN13148.pdf">AN13148: i.MX RT1170 Low-Power
Modes</a> and
<a href="https://www.nxp.com/docs/en/application-note/AN13104.pdf">AN13104: Debug and Application for i.MX RT1170 Clock and Low Power
Feature</a> describe
the complexities of 11xx clock and power management.</li>
</ul>
<h2 id="embedded-rust"><a class="header" href="#embedded-rust">Embedded Rust</a></h2>
<p>If you're brand new to embedded Rust, read through <a href="https://docs.rust-embedded.org/book/intro/index.html">The Embedded Rust
Book</a>. This will help you
understand some of the concepts that appear throughout imxrt-rs packages. Once
you've read through the book, also check out the resources listed on the front
page.</p>
<h2 id="software-references"><a class="header" href="#software-references">Software references</a></h2>
<p>If you're looking for external code references, check out</p>
<ul>
<li>the <a href="https://www.zephyrproject.org/">Zephyr Project</a>.</li>
<li>the ARM CMSIS Packs. Here's the <a href="https://developer.arm.com/embedded/cmsis/cmsis-packs/devices/NXP/MIMXRT1062XXXXA">MIMXRT1062
pack</a>;
NXP and ARM also provide CMSIS packs for the other i.MX RT variants.</li>
<li>NXP's MCUXpresso SDK, available
<a href="https://www.nxp.com/design/software/development-software/mcuxpresso-software-and-tools/mcuxpresso-software-development-kit-sdk:MCUXpresso-SDK">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-new-mcus"><a class="header" href="#contributing-new-mcus">Contributing new MCUs</a></h1>
<p>The imxrt-rs project has various levels of support for about eight i.MX RT MCUs
in the 1000 series. We also have basic support for one core of one 1100 MCU.
However, we do not support all MCUs within the 1000 and 1100 series, and we have
no support for the 500 and 600 series. We welcome your support to add new MCUs.</p>
<p>This document summarizes the steps for contributing new MCU support in the
imxrt-rs project. It also notes the challenges you may face when contributing a
new MCU.</p>
<p>This document is comprehensive, and it assumes that the project has <em>no</em> support
for the MCU you're considering. If the project has <em>partial</em> support for your
MCU, you can skip some of these steps. Read the effort estimates section to
understand which sections you can skip.</p>
<p>If you're having issues contributing a chip, <a href="./index.html#contact">reach out</a>
to an imxrt-rs maintainer.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Your MCU contribution requires that you study and modify packages throughout the
imxrt-rs ecosystem. Therefore, you should be familiar with <a href="./ecosystem_walkthrough">the imxrt-rs
ecosystem</a>, especially the packages used for</p>
<ul>
<li>booting the MCU.</li>
<li>specifying peripheral registers.</li>
<li>defining drivers.</li>
</ul>
<p>The rest of this document elides discussions of imxrt-rs packages, since they're
covered in the ecosystem walkthrough.</p>
<p>Familiarize yourself with the recommended <a href="./external_docs.html">external
documentation</a>. In particular,</p>
<ul>
<li>acquire the <strong>reference manual</strong> for your MCU.</li>
<li>locate the <strong>SVD</strong> for your MCU. These can be found in CMSIS Pack files.
Find links to CMSIS Pack files under <a href="./external_docs.html#software-references">software
references</a>.</li>
</ul>
<p>You'll need the reference manual to understand your MCU's start-up and
peripheral capabilities. You'll use the SVD to generate the register access API
in <code>imxrt-ral</code>.</p>
<p>You'll need some kind of <a href="./flash_debug">flashing / debugging tool</a> that works
with your MCU and target system. This guide assumes that some tool already
supports your system.</p>
<h2 id="effort-estimates"><a class="header" href="#effort-estimates">Effort estimates</a></h2>
<p>Use this section to understand the general effort required to support your MCU.
These estimates can help you understand what kinds of contributions you'll make,
and what efforts you can skip.</p>
<h3 id="1000-mcus"><a class="header" href="#1000-mcus">1000 MCUs</a></h3>
<p>The 1010 and 1060 MCUs are our best-supported MCUs. These MCUs have dedicated
support in <code>imxrt-hal</code>. Boards carrying these MCUs support our hardware testing.
If you're bringing up a new board with these MCUs, you should only need a boot
configuration crate; see <a href="new_mcus.html#booting">booting</a> for more information.</p>
<p>Other 1000 MCUs that have <code>imxrt-ral</code> support, like the 1020 and 1050, are not
tested on hardware. Although <code>imxrt-hal</code> tests its baseline build against these
MCUs, these MCUs do not have dedicated <code>imxrt-hal</code> support. This means clock
control and specialized drivers are not available or tested. Additionally, there
may not be complete boot support for these MCUs. Nevertheless, adding
<code>imxrt-hal</code> support for these MCUs should be the easiest way to contribute an
MCU.</p>
<p>1000 MCUs that do not have <code>imxrt-ral</code> support, like the 1040, will require
changes throughout the imxrt-rs ecosystem. We still expect these efforts to be
easier than adding 1100, 500, and 600 MCU support.</p>
<h3 id="1100-mcus"><a class="header" href="#1100-mcus">1100 MCUs</a></h3>
<p>The 1170 series, specifically the 1176, has basic <code>imxrt-hal</code> support, enough
for simple hardware testing. See <a href="https://github.com/imxrt-rs/imxrt-hal/issues/118">the <code>imxrt-hal</code> tracking
issue</a> for more information.</p>
<p>Other 1100 MCUs require boot and <code>imxrt-ral</code> support. We expect this to be
straightforward, since we've shown support for at least one 1170 MCU. We
generally expect that the baseline <code>imxrt-hal</code> drivers will work on these MCUs.</p>
<p>We have not shown any dual-core support for any 1100 MCU. We welcome your help
to demonstrate this feature.</p>
<h3 id="500-and-600-mcus"><a class="header" href="#500-and-600-mcus">500 and 600 MCUs</a></h3>
<p>Peripherals in these MCUs are different than what we support in <code>imxrt-hal</code>.
This means that <code>imxrt-hal</code> drivers may not be compatible, and you may need to
build new drivers. Despite peripheral differences, we might be able to boot the
Cortex-M core with our existing packages. These MCUs will require support in
<code>imxrt-ral</code>; this may have unanticipated challenges, since it hasn't been
attempted.</p>
<p>Support for the DSP co-processors requires Xtensa support in the Rust compiler.
This exceeds the scope of our project. Follow <a href="https://github.com/esp-rs/rust">esp-rs' fork of the Rust
compiler</a> and <a href="https://github.com/espressif/llvm-project">Espressif's fork of
LLVM</a> to understand support for this
architecture.</p>
<h2 id="booting-1"><a class="header" href="#booting-1">Booting</a></h2>
<p>i.MX RT MCUs have various ways to boot. If your MCU and target system support
serial NOR flash over FlexSPI, it should be simple to support your MCU in
<code>imxrt-rt</code> and <code>imxrt-boot-gen</code>. To understand your MCU's booting methods,
consult the &quot;System Boot&quot; (or equivalent) section of the reference manual.</p>
<p><code>imxrt-rt</code> may already support your chip; see its API documentation for more
information. <code>imxrt-boot-gen</code> has <a href="https://github.com/imxrt-rs/imxrt-boot-gen/issues/6">an
issue</a> that describes how
to evaluate the FlexSPI configuration block for compatibility, and how to define
a FlexSPI configuration block for your MCU and board. Direct <code>imxrt-boot-gen</code>
questions to that issue.</p>
<p>Once <code>imxrt-boot-gen</code> supports your MCU, you'll need a FCB crate that's
compatible with your target system's external flash. If your target system is a
publicly-available development board, like a NXP EVK, we would be happy to help
you maintain a FCB crate within the <code>imxrt-boot-gen</code> repository.</p>
<p>If your MCU or target system do not support booting from serial NOR flash over
FlexSPI, then there's more work to add boot support. Specifically, <code>imxrt-rt</code>
may need to place the program image differently, and <code>imxrt-boot-gen</code> may need a
new API for defining configuration blocks. Once you understand the boot support
required for your system, open issues in their respective repositories.</p>
<h2 id="register-access-layer-1"><a class="header" href="#register-access-layer-1">Register access layer</a></h2>
<p><code>imxrt-ral</code> is our preferred peripheral access crate for i.MX RT MCUs. It's the
foundation on which we build <code>imxrt-hal</code>. By adding support for your MCU into
<code>imxrt-ral</code>, you should be able to realize parts of <code>imxrt-hal</code> for free.</p>
<p>We generate <code>imxrt-ral</code> from SVD files. We patch those SVD files before code
generation, then consolidate the peripheral blocks to ensure cross-MCU
compatibility. After you acquire your MCU's SVD, see the <code>imxrt-ral</code>
contribution documentation for more information on generating <code>imxrt-ral</code>.</p>
<p>Issues you may face include an SVD that is <strong>superficially different</strong> from
supported i.MX RT SVDs. We typically resolve these issues by SVD patches and
codegen transforms. It's important to address these differences to ensure a
clean integration into <code>imxrt-hal</code>.</p>
<p>Larger issues include an SVD -- actually, an MCU -- that is <strong>fundamentally
different</strong> from already-supported i.MX RT MCUs. This means that peripheral
layouts or registers are completely different. To catch these issues before
writing any code, use your MCU's reference manual to understand peripheral
capabilities. Then, compare your MCU's peripherals against those exposed by
<code>imxrt-ral</code>. Focus on the peripherals that have drivers in <code>imxrt-hal</code>.</p>
<p>Fundamental differences should not prevent us from supporting your MCU in
<code>imxrt-ral</code>. But, depending on the differences, it may complicate an integration
into <code>imxrt-hal</code>. If you're not interested in new driver development, then it
may not be worthwhile to add <code>imxrt-ral</code> support for your MCU.</p>
<p>The i.MX RT 600 series fall into the latter category. Since the baseline
peripherals vary from peripherals in the 1000 and 1100 series, we cannot support
these MCUs in today's <code>imxrt-hal</code> without new driver development. On the other
hand, if we were to add i.MX RT 1040 or 1160 support to <code>imxrt-ral</code>, we would
expect <code>imxrt-hal</code> support to come for free, since most baseline peripherals are
identical to what we already support.</p>
<h2 id="hardware-abstraction-layer-1"><a class="header" href="#hardware-abstraction-layer-1">Hardware abstraction layer</a></h2>
<p>If you can boot your MCU, and if <code>imxrt-ral</code> supports your MCU, try to add
support for your MCU in <code>imxrt-hal</code>. In the best case, all drivers build and
work for your system. In the worst case, you need to develop new drivers.</p>
<p>The baseline <code>imxrt-hal</code> exposes drivers that it believes are common across all
supported MCUs. This includes drivers for GPIOs, LPUART, and LPSPI, among
others. Study the <code>imxrt-hal</code> contributing docs to make sure this build still
works when your MCU is available in <code>imxrt-ral</code>.</p>
<p>If the baseline <code>imxrt-hal</code> fails to build once your MCU is available in
<code>imxrt-ral</code>, this may mean that the common drivers are not really common. Open
an issue in <code>imxrt-hal</code> if you notice this failure, and we can help you evaluate
the next steps.</p>
<p>Once the common drivers build for your MCU, you'll receive most of the
<code>embedded-hal</code> implementations. However, you may want to</p>
<ul>
<li>add specialized drivers that are specific to your chip.</li>
<li>re-export existing drivers that are compatible with your chip.</li>
</ul>
<p>You can achieve this with chip features within <code>imxrt-hal</code>. Study the module
layout and feature usage to understand how you can extend <code>imxrt-hal</code> support
for your MCU's drivers. The contributing documentation has more information.</p>
<p>To take advantage of peripheral-pin type states in <code>imxrt-hal</code>, consider
contributing MCU support into <code>imxrt-iomuxc</code>. See the <code>imxrt-iomuxc</code> contributor
documentation for more information. However, this can be a non-trivial effort,
since we do not have complete automation to help with the integration.
Therefore, as of 0.5 <code>imxrt-hal</code>, the <code>imxrt-iomuxc</code> integration is optional;
you can use all drivers without dedicated pad objects and pin traits.</p>
<p><code>imxrt-hal</code> includes in-tree examples based on a thin board support package.
Once the ecosystem supports your MCU, you should be able to add support for your
board and use existing examples for hardware testing. The <code>imxrt-hal</code>
contributor docs discuss how you can add board support.</p>
<h2 id="extra-packages-1"><a class="header" href="#extra-packages-1">Extra packages</a></h2>
<p>We expect that <code>imxrt-dma</code> and <code>imxrt-usbd</code> will work as-is with MCUs in the
1000 and 1100 series. These same packages may not be portable to 500 and 600
MCUs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
